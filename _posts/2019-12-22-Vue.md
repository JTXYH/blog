---
layout:     post
title:      Vue
subtitle:   强大的前端框架
date:       2019-12-22
author:     极客小祥
header-img: img/text/WEB.jpg
catalog: true
tags: 
    - WEB
---

# 基本使用
#### 1、引入

```html
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
```

#### 2、插入文本值：\{\{名字\}\}

```html
<div id="t1">
    {% raw %}
    <p>{{ message }}</p>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data: {
        message: 'Hello Vue.js!'
    }
})
```

#### 3、插入html代码：v-html

```html
<div id="t1">
    {% raw %}
    <div v-html="message"></div>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data: {
        message: '<h1>这个是插入的html</h1>'
    }
})
```

#### 4、绑定属性：v-bind

```html
<div id="t1">
    {% raw %}
    <input v-bind:disabled="use"/>
    // 可以缩写为下面这个
    <input :disabled="use"/>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data: {
        use: true  // 给true就为不可输入
    }
})
```

#### 5、判断是否显示元素：v-if

```html
<div id="t1">
    {% raw %}
    <input v-if="use"/>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data: {
        use: false  // false就是不显示该元素
    }
})
```

#### 6、实现双向数据绑定：v-model
* 指令用来在 **input、select、textarea、checkbox、radio** 等表单控件元素上创建双向数据绑定

```html
<div id="t1">
    {% raw %}
    <span>{{msg}}</span>
    <input v-model="msg"/>
    {% endraw %}    
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data: {
        msg: '双向改变' // 当改变input中的值后，span中的值也会改变
    }
})
```

#### 7、对按钮监听事件：v-on

```html
<div id="t1">
    {% raw %}
    <span>{{msg}}</span>
    <input v-model="msg"/>
    // 给按钮绑定了一个click事件
    <button v-on:click="changeMsg">点我改变值</button>
    // 可以缩写为下面这个
    <button @click="changeMsg">点我改变值</button>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data: {
        msg: '双向改变'
    },
    methods:{
        changeMsg:function(){
            this.msg = '我改变了值' // 点击会把span和input中的值改变
        }
    }
})
```

#### 8、过滤器
1. 普通使用：**\{\{ 接收的参数名字 \| 过滤器名字 \}\}**
2. 在v-bind中使用：\<button v-bind:id="接收的参数名字 \| 过滤器名字"\>\</div\>
3. 可以使用多个过滤器：**\{\{ 接收的参数名字 \| 过滤器名字1 \| 过滤器名字1 ...\}\}**
4. 可以接收参数：**\{\{ 参数1名字 \| 过滤器名字('参数2',参数3名字) \}\}**
    * **参数1的值**为过滤器的**第一个**参数
    * 带引号的**参数2**为过滤器**第二个**参数
    * **参数3的值**为过滤器的**第三个**参数

```html
<div id="t1">
    {% raw %}
    <span>{{msg | fil('参数2直接就是值',msg3)}}</span>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data: {
        msg: '过滤器'
    },
    filters:{
        // 这里的value就是msg的值
        fil:function(value1,value2,value3){
            if(value1 == "过滤器"){
                return "是过滤器所以返回这个："+value2;
            }else{
                return "不是过滤器："+value3;
            }
        }
    }
})
```

# 条件语句

#### 1、使用v-if和v-else

```html
<div id="t1">
    {% raw %}
    <template v-if='ok'>
        <h2>只要不是false我都会出现</h2>
    </template>
    <template v-else='ok'>
        <h2>是false我会出现</h2>
    </template>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data: {
        ok: true,
    },

})
```

#### 2、使用v-else-if

```html
<div id="t1">
    {% raw %}
    <template v-if='ok === 1'>
        <h2>是1我就会出现</h2>
    </template>
    <template v-else-if='ok === 2'>
        <h2>是2我就会出现</h2>
    </template>
    <template v-else-if='ok === 3'>
        <h2>是2我就会出现</h2>
    </template>
    <template v-else='ok'>
        <h2>不是1或2或3我会出现</h2>
    </template>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data: {
        ok: 1,
    },

})
```

#### 3、使用v-show
* 不管条件是真还是假，第一次渲染的时候都会编译出来，也就是标签都会添加到DOM中。
* 之后切换的时候，通过**display: none;**样式来显示**隐藏元素**，**只是改变css的样式**，几乎不会影响什么性能。

```html
<div id="t1">
    {% raw %}
    <template v-show='ok'>
        <h2>只要不是false我都会出现，可以设置css隐藏我</h2>
    </template>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data: {
        ok: true,
    },
})
```

# 循环语句

#### 1、遍历数组
* **v-for='遍历是的别名 in 数组名字'**

```html
<div id="t1">
    {% raw %}
    <ol>
        <template v-for='a in arr'>
            <li>
                {{a.value}}
            </li>
            <li>这个可以自定义设置，每次循环都会打印</li>
        </template>
    </ol>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data: {
        arr:[
            {value:"我是value1"},
            {value:"我是value2"},
            {value:"我是value3"}
        ]
    },

})
```

#### 2、遍历对象
* **v-for='遍历是的别名 in 对象'**

```html
<div id="t1">
    {% raw %}
    <ol>
        <template v-for='key in obj'>
            <li>
                {{key}}
            </li>
            <li>这个可以自定义设置，每次循环都会打印</li>
        </template>
    </ol>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data: {
        obj:{
            key1:"我是value1",
            key2:"我是value2",
            key3:"我是value3"
        }
    },

})
```

#### 3、输出key和value和index
* **v-for='(遍历是的别名,key,index) in 对象'**

```html
<div id="t1">
    {% raw %}
    <ol><!--第一个遍历是的别名，遍历出的是value，第二个key是键的名字，第三个index是索引值从0开始-->
        <template v-for='(value,key,index) in obj'>
            <li>
                {{index+1}} : {{key}} : {{value}}
            </li>
            <li>这个可以自定义设置，每次循环都会打印</li>
        </template>
    </ol>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data: {
        obj:{
            key1:"我是value1",
            key2:"我是value2",
            key3:"我是value3"
        }
    },

})
```

#### 4、迭代数
* **v-for='遍历时的别名 in 数'**

```html
<div id="t1">
    {% raw %}
    <template v-for='n in 10'>
        <!-- 默认不换行，加上br每输出一次换一次行 -->
        {{n}}<br/>
    </template>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1'
})
```

# 计算属性

#### 1、基本使用
* 通过在**computed**中对值进行计算

```html
<div id="t1">
{% raw %}
    <p>{{msg}}</p>
    <!-- 当msg发生改变的时候，comMsg会自动发生改变 -->
    <p>{{comMsg}}</p>
{% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data:{
        msg:'字符串',
    },
    computed:{
        // 默认提供了一个getter方法
        comMsg:function(){
            return "我是计算后的"+this.msg;
        }
    }
})
```

#### 3、computed和methods区别
* 效果上两个都是一样的，但是**computed**是基于它的**依赖缓存**，只有**相关依赖发生改变**时才会重新取值，**methods**在每次渲染页面的时候都会执行一次

#### 3、提供一个setter方法

```html
<div id="t1">
    {% raw %}
    <p>{{name}}--{{age}}</p>
    <p>{{msg}}</p>
    {% endraw %}
</div>
```

```javascript
var t1 = new Vue({
    el: '#t1',
    data:{
        name:'我是没修改的名字',
        age:11,
    },
    computed:{
        msg:{
            // setter方法
            set:function(newValue){
                // 修改的时候传入一个对象，获取传入的name值
                this.name = newValue.name + '我是修改后的名字';
                // 获取传入的age值
                this.age = newValue.age; 
            },
            // getter方法
            get:function(){
                return this.name+'===='+this.age;
            }
        }
    }
})
```

# 监听属性
* 使用watch获取**值属性的变化**

    ```html
    <div id="app">
        {% raw %}
    	<p>计数器：{{count}}</p>
        <!-- 每次点击都会加1，@click是v-on:click的缩写 -->
    	<button @click='count++'>点击加1</button>
        {% endraw %}
    </div>
    ```

    ```javascript
    var vu = new Vue({
		el:'#app',
		data:{
			count:1 //给 count默认值
		}
	})
    // 监听值的变化
	vu.$watch('count',function(newVal,oldVal){
		console.log('旧的value值是：'+oldVal+'======'+'新的value值是'+newVal);
	})
    ```

* **实时监听数据变化并改变自身的值**

    ```html
    <div id="app">
        {% raw %}
    	<input type="text" v-model='str1'>
    	<input type="text" v-model='str2'>
        {% endraw %}
    </div>
    ```

    ```javascript
    var vu = new Vue({
		el:'#app',
		data:{
			str1:'1',
			str2:'1'
		},
		methods: {
		},
		computed :{
		},
        // 监控str1的变化来改变str2的值
		watch:{
			str1:function(val){
				this.str1 = val;
                // str1如果输入10，str2就是100
				this.str2 = this.str1*10;
			},
			str2:function(val){
                // 必须和str1中的对应起来，上面是*10，这里必须是/10
                // 不然会卡死
				this.str1 = val/10;
				this.str2 = val;
			}
		}
	})
    ```

# 样式绑定
#### 1、绑定普通css

```html
<style type="text/css">
    .bgc {
        background-color:red;
    }
    .fc{
        color:white;
    }
</style>
<div id="app">
    <p v-bind:class='{bgc:isBgc,fc:isFc}'>这个p标签</p>
</div>
```

```javascript
var vu = new Vue({
    el:'#app',
    data:{
        // 设置为false就是不绑定class属性
        isBgc:true,
        isFc:true
    }
})
```

#### 2、绑定对象

```html
<style type="text/css">
    .bgc {
        background-color:red;
    }
    .fc{
        color:white;
    }
</style>
<div id="app">
    <p v-bind:class='obj'>这个p标签</p>
</div>
```

```javascript
var vu = new Vue({
    el:'#app',
    data:{
        // 设置为false就是不绑定class属性
        obj:{
            bgc:true,
            fc:true
        }
    }
})
```

#### 3、传递数组

```html
<style type="text/css">
    .bgc {
        background-color:red;
    }
    .fc{
        color:white;
    }
</style>
<div id="app">
    <p v-bind:class='[str1,str2]'>这个p标签</p>
</div>
```

```javascript
var vu = new Vue({
    el:'#app',
    data:{
        // 设置为false就是不绑定class属性
        str1:'bgc',
        str2:'fc'
    }
})
```

#### 4、内联样式

```html
<div id="app">
        <!-- 这里写style，中间不能写- 有-这个的标签使用首字母大写代替 -->
    <p v-bind:style='{color:str1,backgroundColor:str2}'>这个p1标签</p>
</div>
<!-- 使用对象绑定，可以使用数组绑定多个对象，一个对象不用使用数组 -->
<div id="app2">
    <p v-bind:style='[styleObj1,styleObj2]'>这个p2标签</p>
</div>
```

```javascript
var vu = new Vue({
    el:'#app',
    data:{
        str1:'white',
        str2:'red'
    }
})

var vu2 = new Vue({
    el:'#app2',
    data:{
        styleObj1:{
            color: 'red',
        },
        styleObj2:{
            fontSize: '30px'
        }
    }
})
```

# 事件处理器

#### 1、使用v-on监听

```html
<div id="app">
    <button v-on:click='at("点击按钮弹出")'>点击</button>
    <!-- <button @click='at("点击按钮弹出")'>点击</button> -->
</div>
```

```javascript
var vu = new Vue({
    el:'#app',
    methods:{
        at:function(message){
            alert(message);
        }
    }
})
```

#### 2、事件修饰符

* **捕获**：**从外到内**依次执行click事件
* **冒泡**：**从内到外**依次执行click事件

1. **.stop**：**阻止**事件继续传播 即阻止它的**捕获和冒泡过程**

    ```html
    <div v-on:click="wb">外部点击
        <!-- 加了stop后，当点击内部的的button时不会触发外部的div的点击事件 -->
        <button  v-on:click.stop="nb">内部点击</button>
    </div>
    ```

2. **.prevent**：**阻止**默认事件的发生

    ```html
    <!-- 这里会阻止a标签的默认刷新 -->
    <a href="#" v-on:click.prevent>点击</a>
    ```

3. **.capture**：使用事件**捕获模式**

    ```html
    <!-- 当点击nb3的时候，会先执行wb1，然后执行nb3，最后执行wb2 -->
    <div v-on:click.capture="wb1">外部点击1
        <div  v-on:click="wb2">外部点击2
            <div  v-on:click="nb3">点击3</div>
        </div>
    </div>
    ```

4. **.self**：元素**自身触发**时才会执行自身处理函数

    ```html
    <!-- 当点击nb3的时候不会触发到wb2，只有当点击wb2的时候才会触发wb2 -->
    <div  v-on:click.self="wb2">外部点击1
        <div  v-on:click="nb3">点击2</div>
    </div>
    ```

5. **.once**：**只触发一次**处理函数

    ```html
    <!-- 之后触发一次nb3按钮的函数，之后点击都不会触发 -->
    <div  v-on:click.once="nb3">点击1</div>
    ```

#### 3、按键修饰符

* 使用：**v-on:keyup**或者**@keyup**操作，可以配合js中的**字母和数字键一起使用**

按键别名      |  代表按键 |
---          |   ---     |
**.enter**   |  Enter    |
**.tab**     |  Tab      |
**.esc**     |  Esc      |
**.delete**  |  Delete   |
**.space**   |  Space    |
**.up**      |  Up       |
**.down**    |  Down     |
**.left**    |  Left     |
**.right**   |  Right    |
**.ctrl**    |  Ctrl     |
**.alt**     |  Alt      |
**.shift**   |  shift    |
**.meta**    |  Meta     |

```html
<!-- 按下ctrl+C的时候触发 -->
<p @keyup.ctrl.67='at("点击按钮弹出")'>点击</p>
```

# 表单处理

* 使用**v-model**对表单数据进行双向绑定

#### 1、绑定下拉选框

```html
<div id="app">
    <select v-model="message">
        <option>选择一个</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
    </select>
    {% row %}
    <p>你选择了：{{message}}</p>
    {% endrow %}
</div>
```

```javascript
var vu = new Vue({
    el:'#app',
    data:{
        message:''
    }
})
```