---
layout:     post                     # 使用的布局（不需要改）
title:      Python之多任务                      # 标题 
subtitle:   Python必会1                # 副标题
date:       2018-11-18               # 时间
author:     JTX                      # 作者
header-img: img/text/18-11-14.jpeg         # 这篇文章标题背景图片
catalog: true                        # 是否归档
tags:                                # 标签
    - Python
---


# 多线程

#### 1. 导入**threading**模块

#### 2. 使用threading模块中的**Thread**类

#### 3. 必须要传入的的参数**target=函数名**

#### 4. 运用threading模块中的**start()**方法开启多线程

> **示例代码:**

```python
import time 
import threading
	
def sing():
    """唱歌 5s"""
    for i in range(5):
        print("----正在唱歌------")
        time.sleep(1)
        
def dance():
    """跳舞 5s"""
    for i in range(5):
        print("----正在跳舞------")
        time.sleep(1)
        
def main():
    t1 = threading.Thread(target=sing)
    t2 = threading.Thread(target=dance)
    t1.start()
    t2.start()
    
if __name__ == "__main__":
    main()
```

#### 5. 需要**查看线程数**可以使用threading模块中的**enumerate()**方法

#### 6. 调用**类的多线程方法**

##### 自定义一个**继承于Thread的类**

##### 在里面写一个**run()**方法

##### 再调用自定义的类,使用类中的**start()**方法

> **示例代码:**

```python
import threading
import time

class MyThread(threading.Thread):
    """继承于Thread的类"""
    def run(self):
        for i in range(3):
            time.sleep(1)
            # name属性中保存的是当前线程的名字
            msg = "I'm" + self.name + "@" + str(i)
            print(msg)
        self.login()
        self.register()

    def login(self):
        print("这个是登录")


    def register(self):
        print("这个是注册的代码...")
        
if __name__ == "__main__":
    t = MyThread()
    t.start()
```

#### 7. 多线程中是**共享全局变量**的

#### 8. 传入的参数除了**target = 函数名**外还有**args = ((需要传入的内容,))**

> **target**指定的是这个线程**去哪个函数执行代码**
>
> **args**指定的是**调用函数传入的参数**(传入必须以元组的形式!)

#### 9. 多线程中出现**资源竞争**问题就要使用**互斥锁**来解决,需要使用threading模块中的**创建互斥锁Lock()**函数,**上锁acquire()**方法和**解锁release()**方法

> **示例代码:**

```python
import threading
import time

# 定义一个全局变量
g_num = 0

def test1(num):
    global g_num
    # 上锁,如果之前没被上锁,那么此时上锁成功
    # 如果之前上锁了,那么此时会堵塞在这里,直到这个锁被解开为止
    mutex.acquire()
    for i in range(num):
        g_num += 1
    # 解锁
    mutex.release()
    print("----in test1 g_num=%d----" % g_num)
    
def test2(num):
    global g_num
    mutex.acquire()
    for i in range(num):
        g_num += 1
    mutex.release()
    print("----in test2 g_num=%d----" % g_num)

# 创建一个互斥锁,默认是没有上锁的
mutex = threading.Lock()

def main():
    t1 = threading.Thread(target = test1, args=(10000000,))
    t2 = threading.Thread(target = test2, args=(10000000,))

    t1.start()
    t2.start()

    # 等待上面的线程执行完毕...
    time.sleep(4)
    print("----in main Thread g_num = %d" % g_num)
    
if __name__ == "__main__":
    main()
```

