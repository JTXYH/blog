---
layout:     post                    
title:      JAVA基础                     
subtitle:   Java最基础的知识               
date:       2019-8-20               
author:     JTX                      
header-img: img/text/19-8-20.jpg   
catalog: true                        
tags:                                
    - JAVA
---


# 环境变量配置

**JAVA_HOME**：配置的是**jdk**的根目录<br/>
**path**：配置**bin**目录(%JAVA_HOME%\bin)

# 基本格式

**类名必须和文件名保持一致**

```java
public class 类名{
	// 类名需要驼峰式,第二个单词首字母大写
	public static void main(String[] args) {
		
	}
}

```

#### 1、java工具包
**jdk**：java开发工具包(java development kit),**代码编写依赖jdk**<br/>
**jre**：java运行环境(java runtime environment),**提供javav程序运行的环境**<br/>
**jvm**：java虚拟机(java virtual machine),**确切说程序是在jvm里面运行的(只认识class字节码文件)**<br/>

#### 2、常用cmd命令
**dir**：显示当前路径下的目录<br/>
**cd**：路径操作<br/>
**cls**：清除当前屏幕

#### 3、cmd运行步骤
先写**程序**
编译：**javac 程序名.java**
执行：**java 程序名**

#### 4、注释
**单行注释**：//注释内容  *快捷键*：**Ctrl+/**<br/>
**多行注释**：/\*注释类容\*/  *快捷键*：**Ctrl+Shift+/**<br/>
**文档注释**：/\*\*注释内容\*/(对**类和文档**进行解释)

```java
/*
	多行注释 一般写在类的开头
	写出
		1. 类的功能
		2. 类的实现步骤
*/
public class name{
	// main是程序的主方法 固定格式 程序的入口
	public static void main(String[] args) {
		System.out.println("HelloWorld");

	}
}
```

# 目录文件夹

**src文件夹**：源文件夹 里面存放(包package)java文件

**bin文件夹**：存放编译之后的(包package)class文件

**Class-->Package**规范：**公司域名后缀名+公司名称+其他**
> com/cn/edu.java.other

# 设置相关

**字体大小调节**：**Window->Preferences->Appearance->Colors and Fonts->Basic->Text Font**

**设置统一编码格式为UTF-8**：**Window->Preferences->workspace->Text file encoding**

# eclipse快捷键

**复制**：Ctrl+Alt+上\下键<br/>
**删除**：Ctrl+d<br/>
**回退/前进**：Ctrl+z/y<br/>
**自动补全代码或者提示代码**：Alt+?或Alt+/<br/>
**快速outline视图**：Ctrl+O<br/>
**切换编辑器**：Ctrl+E<br/>
**在当前行上或者下边创建空白**：Shift+Enter及Ctrl+Shift+Enter<br/>
**上下行交换内容或把当前行内容把上或下移动**：Alt+上下方向键<br/>
**复制高亮显示的一行或多行**：Ctrl+Alt+方向上下键<br/>
**当前编辑页面窗口最大化**：Ctrl+M<br/>
**自动引入包和删除无用包**：Ctrl+Shift+O<br/>
**意见提示功能**：Ctrl+1<br/>
**自动生成setter和getter方法**：Alt+Shift+S+R<br/>
**自动生成变量名，自动生成变量**:Alt+Shift+L

# 变量的定义和注意事项

变量定义后，**不赋值不能使用**<br/>
变量有自己的作用范围，变量的**有效范围定义在一对大括号内**<br/>
变量不允许**重复定义**

# 数据类型

#### 1、基本数据类型(四类八种)

> Java默认数据类型是**int**

> 整数默认类型是**int**，小数默认类型是**double**

整数：**byte/short/int/long**

**byte**：1个字节 *-128\~127*<br/>
**short**：2个字节<br/>
**int(默认)**：4个字节<br/>
**long**：8个字节(*过大的数*后面加上**L**)

小数：**float/double(默认)**

**float**：4个字节<br/>
**double**：8个字节

布尔：**boolean**(默认false)

**boolean**：1个字节

单个字符：**char**(默认是'')

**char**：2个字节


#### 2、引用数据类型

**String**：字符串类(默认是**null**)<br/>
**String + 基本类型**：字面量数据类型<br/>
**数组**：数据类型[] 数组变量名 = new 数据类型[长度]<br/>
**任意引用数据类型都存在堆里面**

#### 3、数据类型转换

**自动类型转换**：**范围小(byte)**的可以直接转换为**范围大(int)**的
> **byte -> short -> int -> long -> float -> double**

```java
public class DateVonvert {
	public static void main(String[] args) {
		double b = 1000;  // 出现了类型的自动转换，int自动转换为double
		System.out.println(b);

		byte b = 111;
		int j = b;  // byte转换为int
		System.out.println(j);
	}
}
```

**强制类型转换**：**被转后的数据类型 变量名 = (被转后的数据类型)要被转的数据**

```java
public class DateVonvert {
	public static void main(String[] args) {
		double dd = 3.14;
//      被转后的数据类型 变量名 = (被转后的数据类型)要被转的数据
		int ii = (int) dd;
		System.out.println(ii);

		byte bb = (byte) 200; 
		System.out.println(bb);  // 丢数据
	}
}
```

# 运算符

#### 1、算术运算符

**\+** 加法，连接<br/>
**\-** 减法<br/>
**\*** 乘法<br/>
**/** 除法<br/>
**%**取模，取余数<br/>
**++** 自增1<br/>
**--** 自减1

```java
public class Operator {
	public static void main(String[] args) {
		// + 连接作用，将一个字符串和其他数据连接起来
		// + 任何类型只要和字符串+，所有的数据都变成了字符串
		// + 遇到字符串，变成连接符号"5+5=55"
		System.out.println("5+5="+5+5);
		
		// ++ 写在变量前面和后面的区别
		int i = 5;
		int j = i++;
		// j = i++  ++后算，先把i赋值给j，i自己再++
		System.out.println(i);  // 6
		System.out.println(j);  // 5
		
		int m = 5;
		int n = ++m;
		// n = ++m ++先算，再把m++赋值给n
		System.out.println(m);  // 6
		System.out.println(n);  // 6
	}

}

```

#### 2、赋值运算符

> **=** / **+=** / **-=** / **/=** / **%=**

```java
public class Operator {
	public static void main(String[] args) {
		byte b = 1;
		b = (byte)(b + 1);  // 必须转换 不然报错
		System.out.println(b);
		
		byte b1 = 1;
		b1 += 1;  // 等同于(byte)(b + 1)
		System.out.println(b);
	}
}
```

#### 3、比较运算符

> **==** / **!=** / **<** / **>** / **<=** / **>=**

**结果只有 true 或者 false**<br/>
比较字符串是否一致：**名称1.equals(名称2)**

#### 4、逻辑运算符

> **对两个boolean类型数据之间进行计算结果也是boolean类型**

**&** 与：**一个false，结果就是false**<br/>
**\|** 或：**一个true，结果就是true**<br/>
**^** 异或：**两边相同为false，不相同为true**<br/>
**！** 取反：**!true为false  !false为true**<br/>
**&&** 短路与：**一边是false，另一边不运行**<br/>
**\|\|** 短路或：**一边是true，另一边不运行**

#### 5、三元运算符

公式：**布尔表达式?结果1:结果2**<br/>
结果1和结果2**数据类型保持一致**

> 布尔表达式是true，三元运算符结果就是-->**结果1**
>
> 布尔表达式是false，三元运算符结果就是-->**结果2**

```java
public class Operator {
	public static void main(String[] args) {
		System.out.println(3>2?99:88);  // 99
		System.out.println(3>5?99:88);  // 88
	}
}
```

# 循环控制语句

#### 1、If Else

```java
if(表达式){
	//表达式成立执行这里面的语句
	//语句
}else if(表达式2){

}else{
	//不满足执行这里的语句
}
```

#### 2、While/Do While

两者区别：
	**while 先判断是否满足条件  满足就执行循环体**
	**do while 无论满不满足循环体都先执行一次**

```java
while(判断条件){
	// 成立执行这里的语句
}

do{
	//执行一次
}while(判断条件);
```

#### 3、Switch Case

```java
// switch后表达式满足的数据类型有
// int byte char String(1.7版本) enum(枚举) short
switch(表达式){
// case后的数据类型要和switch表达式的数据类型保持一致
case 表达式1:
	代码逻辑;
	break;
case 表达式2:
	代码逻辑;
	break;
case 表达式n:
	代码逻辑;
	break;
// 前面所有的表达式都不满足执行default语句后的代码
default:
	代码逻辑;
	break;
}
```

#### 4、For

```java
for(表达式1;表达式2;表达式3){
	// 代码逻辑
}

// 增强for循环
for(数组元素数据类型 变量名称:数组变量名){
	// 循环体
}
```

#### 5、Break，Continue，Return

**Break**：直接终止整个循环体，不能单独使用在**if**里<br/>
**Continue**：结束本次循环体，开始下个循环<br/>
**Return**：结束整个方法

#### 6、Scanner使用

**Scanner input = new Scanner(System.in);**，定义输入<br/>
**int a = input.nextInt();**，接收用户输入
**input.close()**，关闭流

#### 7、断点调试

**先双击行首数字出**<br/>
**F6程序往下走一步**<br/>
**F8走到下一个断点处**

# 数组

#### 1、一维数组

**语法**

1. 数据类型[] 变量名 = new 数据类型[长度];<br/>
2. 数据类型[] 变量名 = {值1,值2,值3,值n};<br/>
3. **获取数组长度**：数组名.length;

#### 2、二维数组

**语法**

数据类型[][] 变量名 = 数据类型[m][n];<br/>
数据类型[][] 变量名 = 数据类型[m][];<br/>
数据类型[][] 变量名 = \{\{元素1\},\{元素2\},\{元素3\}\};

```java
// 3表示二维数组的长度是3(存放3个一维数组)
// 4表示每个一维数组里面可以存放4个元素
String[][] strArr = new String[3][4];
System.out.println(strArr.length);  // 打印二维数组的长度
System.out.println(strArr[0].length);  // 打印一维数组长度

```

#### 3、Arrays工具类

```java
Arrays.toString(arr); // 将数组内容转成字符串输出
Arrays.sort(arr);  // 默认从小到大排序
Arrays.copyof(源数组,新数组长度);  // 拷贝数组
Arrays.equals(数组1,数组2); // 判断两个数组是否一致
```

# 排序(Sort)

#### 1、冒泡排序

**效率最慢**

![Screenshot_1.png](https://i.loli.net/2019/07/16/5d2d47d83143340496.png)

```java
int[] arr = {23,2,44,1};

// 控制排序的轮数
for(int i = 0; i<arr.length-1; i++) {
	// 控制元素与相邻元素相比
	for (int j = 0; j < arr.length-1-i; j++) {
		// 判断两个相邻的元素
		if(arr[j]>arr[j+1]) {  // arr[j]位置交换
			int temp = arr[j];
			arr[j] = arr[j+1];
			arr[j+1] = temp;
		}
	}
}
```

#### 2、选择排序

![Screenshot_1.png](https://i.loli.net/2019/07/16/5d2d4aa77b77518584.png)

```java
for(int i = 0; i<arr.length-1; i++) {
	int min = arr[i];  // 定义一个最小值
	int minindex = i;  // 获得最小值的索引
	
	// 判断遍历数组出最小值
	for (int j = i+1; j < arr.length; j++) {
		if (min>arr[i]) {
			min = arr[i];
			minindex = j;
		}
	}
	
	// 交换位置
	int temp2 = arr[i];
	arr[i] = arr[minindex];
	arr[minindex] = temp2;
	}
```

#### 3、插入排序

**效率最快**

![Screenshot_2.png](https://i.loli.net/2019/07/16/5d2d68a13e4fb36354.png)

```java
for (int i = 1; i < arr.length; i++) {
			int temp = arr[i];  // 数组的第二位
			int leftindex = i-1;  // 左侧索引
//          arr[leftindex] 后移
			while (leftindex >= 0 && arr[leftindex] > temp) { 
				arr[leftindex + 1] = arr[leftindex];
				leftindex--;
			}
			// 空位
			arr[leftindex + 1] = temp;
		}
		System.out.println(Arrays.toString(arr));
```

# 类和对象

#### 1、类的创建
```java
public class 类名{
	// static表示静态的
	// 下面都是类的属性
	static String name; // 姓名
	static String gender; //性别
	static int age;
}
```

#### 2、类的方法
1. 权限修饰符：**public static(公共的)，protected(受保护的)，private(私有的)，默认(default)**<br/>
2. 方法返回值：**数据类型，void(无返回值数据类型)**<br/>
3. 方法名()：规范：**首字母小写，第二个单词字母大写，名字不能重复**<br/>
4. 方法的参数：**形式参数，形参  所有数据类型都可以充当形参**

```java
//1.无参无返回值
public static void method1() {
	System.out.println("无参无返回值");
}
//2.无参有返回值：必须加return语句，返回要返回的数据(数据类型必须是返回值的数据类型)
public static String method2() {
	System.out.println("无参有返回值");
	String str = "hello";
	return str;  // 结束当前方法
}
//3.有参无返回值(参数的个数>=1)  可变参数：数据类型...参数名字
public static void method3(int[] arr,int num,int...obj) {
	System.out.println("有参无返回值");
	System.out.println(arr);
}
//4.有参有返回值
public static int method4(String str,int i) {
	System.out.println("有参有返回值");
	return i;  // 必须返回和参数相同的数据类型
}
```

#### 3、创建对象

**语法：类名 对象名 = new 类名();**
```java
Person zhangSan = new Person();
System.out.println(zhangSan);  // 输出内存地址
```
**调用类的属性和方法**
```java
zhangSan.name = "张三";
zhangSan.gender = "男";
zhangSan.age = 20;
System.out.println(zhangSan.name);  // 输出name
```

#### 4、调用方法

**语法：方法名();**
```java
public static void method1() {
	System.out.println("无参无返回值");
}

method1()  // 调用method1方法
```

#### 5、方法重载
1. 方法名**相同**<br/>
2. 参数**数据类型，参数顺序不一样**<br/>
3. 不考虑**返回值和权限修饰符**

```java
public Animal() {
	// 初始化一些变量数据
}

// 构造方法重载
public Animal(String name1) {
	name = name1;
}
```

#### 6、成员变量和局部变量

1. **存在位置不一样**：成员变量在**类里面**，局部变量在**方法里面**<br/>
2. **作用范围不一样**：成员变量在类里**任何地方都可以访问**，局部变量**只可以在方法里面使用**<br/>
3. **内存储存位置不一样**：成员变量在**堆里**，局部变量在**栈里**<br/>
4. **初始值不一样**：成员变量**有初始值，不需要初始化**，局部变量**没有初始值，必须初始化**

# 面向对象三大特性

#### 1、封装

**对私有属性提供对外的公开访问方法**：使用**setter()和getter()**方法

```java
private int age; // 年龄赋值的时候 要进行判断 private修饰成员只能在本类中调用
String tname;
public void setAge(int age1) {
	if (age1 < 22) {
		System.out.println("年龄不合法！");
		System.out.println("年龄默认设置为22岁！");
		age1 = 22;
	}
	age = age1;
}

public int getAge() {
	return age;
}
```

##### lombok使用教程

![Screenshot_1.png](https://i.loli.net/2019/08/27/E4kx7RQMD65Pq1a.png)


##### this关键字

1. 当成员变量与局部变量重名的时候，可以使用this来辨别，**this指代的是当前对象**<br/>
2. this充当**实参**<br/>
3. this可以调用构造函数this()，**必须在代码的第一行**<br/>
4. this可以**访问属性**<br/>
5. this**不能**在static所修饰的方法中运用

##### static关键字

1. 静态方法里面**不能访问非静态成员**  <br/>
2. 如果是static修饰的成员变量，最好初始化<br/>
3. 静态方法中不能使用this
4. 可以和任何权限修饰符一起使用：**public/private/protected/final**
5. 数据是让所有对象**共享**的

**静态代码块**：
```java
static {
	初始化数据，不管创不创建对象都走
	只运行一次
	System.out.println("静态代码块");
}
{
	只有在创建对象的时候才会走这句话
	System.out.println("普通代码块");
}
```

#### 2、继承(extends)

语法：**public class 类1 extends 类2\{\}**，**一个类只能继承一个类**<br/>
子类对象创建时会默认**先执行父类的无参构造**<br/>

![Screenshot_1.png](https://i.loli.net/2019/08/27/DHMSuL4VCrAs3We.png)

##### super
1. 访问父类构造方法(**super()**)
2. 访问父类的**成员变量和成员方法(super.父类变量名/方法名)**

##### 方法重写(override)

前提条件：**必须要有层级关系**
1. 方法重写**出现在子类**里面
2. 方法名，形式参数必须**和父类保持一致**
3. 子类访问**权限修饰符** **>=** 父类的
4. 子类**返回值类型** **<=** 父类的
5. 重写父类方法前面加上：**@Override**

##### 权限修饰符
1. **public**：可以修饰**类和成员变量**，在**整个项目**中都是友好的
2. **protected**：可以修饰**成员变量**，在**整个包内和子类**中友好
3. **默认不写**：可以修饰**类和成员变量**，在**包内**友好
4. **private**：可以修饰**成员变量**，在**本类中**友好
5. **final**：可以修饰**常量**，被修饰的方法中**不能被重写**，在继承中**不被继承**

![Screenshot_1.png](https://i.loli.net/2019/08/27/U1urxypL9gCm3aS.png)

#### 3、多态

发生多态条件：
1. 父类对象指向任何一个子类的实例(对象)
2. 编译时数据类型(**=左边**)与运行时数据类型(**=右边**)不一致时
3. 子类对象转成父类实例**向上转型**
4. 创建对象发生多态：**父类对象 名称 = new 子类对象();**
5. 父类对象转成子类实例(强制转换)，**向下转型**，要配合**instanceof一起使用**
6. 访问**成员变量**看**=左边**的数据，访问**成员方法**看**=右边**
弊端：**无法访问子类特有的成员(变量、方法)**

##### instanceof
使用：**父类实例 instanceof　子类对象**

![Screenshot_1.png](https://i.loli.net/2019/08/28/DwuSfNEd2v3st6g.png)

# 抽象类和接口

#### 1、抽象类
**使用条件**：当所有子类都需要重新父类的逻辑时，父类方法体就变得没有意义，就把父类方法声明成抽象的方法<br/>
**使用方法**：**访问权限修饰符 abstract 返回值类型 方法名();**<br/>
**注意**：抽象类**不能创建对象**，体现在多态上，抽象类的**构造方法**主要是**满足子类对象的创建**

![Screenshot_3.png](https://i.loli.net/2019/08/28/CU2NlKBxRVshGtH.png)
![Screenshot_4.png](https://i.loli.net/2019/08/28/voj3PEmrsXO4wpT.png)

#### 2、接口(interface)

**创建接口**
```java
public interface 接口名{

}
```
**项目命名规范**
1. \*\*\*\***Dao/DAO.java**，*UserDao.java*
2. \*\*\*\***Service.java**，*UserService.java*

**接口中的内容**<br/>
常量必须为**public static final修饰**，常量名字必须都是**大写**<br/>
抽象方法必须为**publice abstract**修饰<br/>
**JDK1.8**之后有**普通方法**，但必须使用**default static**修饰<br/>
访问父类的普通方法使用**super.方法名()**

**接口的作用**
1. 接口可以通过**implements实现多调用**，一个类可以实现多个接口
2. 主要用于**多态的使用**
3. 接口和接口之间可以实现**多继承**

#### 3、接口和抽象类的区别

共同点：都**不能实例化**，都用于**多态**<br/>
不同点：接口只有**常量和抽象方法和default/static所修饰的功能方法**，抽象类有**成员变量，成员方法，抽象方法，构造方法，静态代码块**

# 异常

异常**Exception**(类) ---> **可以处理**<br/>
错误**Error**(类) ---> JVM抛出，**程序直接终止**<br/>
它们有共同的**父类:Throwable**<br/>
![Screenshot_2.png](https://i.loli.net/2019/09/02/2vozg3MARJaXrEu.png)

异常可以分为两大类：
1. **可检测到的异常checkedException**：PasreException，SQLException，ClassNotFoundException，IOException
2. **运行时的异常RuntimeException**：NPE，ClassCastException

#### 1、捕获异常的方法
**String getMessage()**：获得详细的异常信息字符串内容<br/>
**void printStackTrace()**：将详细异常信息通过流打印(输出)至控制台<br/>
```java

出现多个异常的情况下，只走其中一个异常，就是说catch只走一次！

try{
	 可能会出现异常的代码

}catch(异常类  变量名 ){  捕获具体的异常类的
	//处理异常信息
	//避免捕获不处理异常信息

	1.后端开发(服务器端开发)--->java项目运行在Linux服务器
	异常日志记录异常信息(将异常信息写入异常日志文件)  slf4j  log4j 

	2.异常信息传递 (throw)  将异常信息从底层到顶层全部输出。
	将当前异常类对象 封装到 级别高的异常对象里面

	3.异常工具类返回的错误信息

return ServerResponse.error("msg","code");
		
}catch(异常类  变量名 ){
	处理异常信息的方式
	
	System.out.println(exception.getMessage()); 

	exception.printStackTrace();
}
finally{

	释放资源

	不管是否有异常出现  都会执行的
}
```

![Screenshot_1.png](https://i.loli.net/2019/09/02/AOHqGpQRy5eNLKi.png)

#### 2、抛出异常 throws
throw 声明**抛出一个具体的异常对象**
1. 异常信息传递 (throw)
2. 结束程序
3. 与自定义异常结合使用

```java
public static  void a() throws ArithmeticException{

		将异常类抛出给上级(调用者);
		System.out.println("异常之前");
	}

public static int calMoney(String boorowTime, String returnTime)
if(boorowTime == null || returnTime == null){
	抛出一个异常信息
	throw new NullPointerException("参数数据不能为null") 
	遇见throw程序直接结束
}
```

**将String时间数据转换为Data**
```java
String pattren  = "yyyy-MM-dd HH-mm-ss"; // 创建一个格式
SimpleDataFormat dateFormat = new SimpleDataFormat(pattren);

// 格式化数据(解析) 将字符串解析为data类型的数据
// 有一个可检测的异常
try{
	Data borrowData = dateFormat.parse(boorowTime);
	Data returnData = dateFormat.parse(returnTime);

	// 计算两个日期的间隔
	// 将Date类型的数据转换成数值型的数据
	long borrow = borrowData.gettimr(); // data代表的是时间的毫秒数
	long return1 = returnData.gettimr();

	int hour = (int)((return1 - borrow)/1000/3600); // 转换成int类型的时间
} catch(ParseException e){
	e.printStackTrace();
}
```

# lang包常用类

#### 1、Integer
**包装类分为四类八种**<br/>
**Byte,Shory,Integer,Long,Float,Double,Character,Boolean**<br/>
**成员变量的数据类型**使用包装类

Integer介绍：
1. **final所修饰**的类
2. 继承于**Number**
3. 实现了一个**Comparable<Integer>**接口
4. 赋值只能给**数字类型和数字类型的字符串**

```java
基本类型的数据转换成了一个包装类 ---> 装箱操作
// 底层实现：Integer num = Integer.valueOf(100);
Integer num = 100;

包装类的对象转换成基本类型的数据 ---> 拆箱操作
// 底层实现：int num1 = num.intValue();
int num1 = num;

Integer num2 = new Integer(100);
Integer num3 = new Integer("100");

int num4 = 100;
Integer num5 = 100;
Integer num6 = 100;
Integer num7 = 200;
int num8 = 200;

System.out.println(num2=num2); false
```
这里实现了包装类的拆箱操作
```java
System.out.println(num2=num4); true
System.out.println(num4=num5); true

System.out.println(num1=num4); false
```
整数缓存池：**数组 Short[] Integer[] Long[],范围在-128~127之间，**
两个数比较**在这之间为True，否则为False**
```java
System.out.println(num5=num6); true
System.out.println(num7=num8); false
```

##### Integer功能方法
```java
比较数据类型是否一致
//equals方法从Object继承 是Integer重写父类的euqals
System.out.println(num1.equals(num2));
//返回值只有0 -1 1
System.out.println(Integer.compare(num1, num2)); 
//从Comparable实现过来的
System.out.println(num1.compareTo(num2));
// Objectes JDK1.7后有的
System.out.println(Objects.equals(num1, num2));

String 和 Integer转换
String strNum = "100";
int num = new Integer(strNum);  //第一个方法
Integer num2 = Integer.valueOf(strNum); //第二个方法
Integer num3 = Integer.parseInt(strNum); //第三个方法

Integer 转换成 String
Integer in = 100;
String str = in.toString(); // 转换成字符串

```

#### 2、Character

##### Character功能方法
```java
System.out.println(Character.MAX_RADIX); //最大进制 36
System.out.println(Character.MIN_RADIX); //最小进制 2

将字符串转换为指定进制
String str = "110";
char[] chs = str.toCharArray();
// 将第一位转换为10进制的数
System.out.println(Character.digi(chs[0], 10)); 

Character ch1 = '我';

if(Character.isLetter(ch1)){
	判断是否为大小写字母
	Character.toLowerCase(ch1); //小写
	Character.toUpperCase(ch1);  // 大写
}else if(Character.is.Digit(ch1)){
	判断是否为数字
}else if(Character.isWhitesace(' ')){
	判断是否为空字符串
}
```

#### 3、String

实现了**java.io.Serializable, Comparable<String>, CharSequence接口**

**创建字符串**
```java
构造
String str1 = new String();

String str2 = new String("hello");

byte[] bytes = {78,98,99}
String str3 = new String(bytes); //将字节数组转为字符串内容

获得字符串的字节内容
注意编码和解码格式统一
//使用默认的编码格式解析成字节数组
System.out.println("哈哈哈哈".getBytes());
// 将字节数组使用指定的格式进行编码处理
System.out.println("哈哈哈哈".getBytes("GBK").length);
// 将字节数组使用指定的编码格式进行解码处理
System.out.println("哈哈哈哈".getBytes(),"UTF-8");

Charset代表具体的编码格式
// 查看当前工作空间默认编码格式
System.out.println(Charset.defaultCharset());

将字符数组转换为字符串内容
char[] ch = {23,'a','家','好'};
String str4 = new String(ch);

toCharArray字符数组转换为字符串内容操作
String str4 = new String("啊啊啊啊".toCharArray());
```

##### String功能方法
```java
String str = "abc";

获得字符串指定索引的字符内容(返回值是char类型)
str.charAt(1);  // 不能超过字符串的总长度

字符串之间的比较(返回值是int类型)
str.compareTo("abc"); //ASII码值相减
str.compareToIgnoreCase("ABC"); // 不区分大小写进行比较
str.equals("abc"); // 返回值是boolean类型
str.equalsIgnoreCase("ABC"); // 不区分大小写进行比较，返回值是boolean类型

将指定的字符串内容追加到字符串的末尾(返回值是String类型)
str.concat("_123"); // abc_123，返回的是一个新的字符串内容，str不会发生改动

判断字符串中是否包含指定字符序列内容(返回值是boolean类型)
str.contains("a");  // 判断str中是否包含a

将任意类型的数据转换为字符串(返回值是String类型)
String.valueOf(1);

判断字符串中是否以某个类型开头和结尾(返回值是boolean类型)
str.endsWith("a"); // 判断是否是a结尾
str.startsWith("b"); // 判断是否是b开头

返回字符串的哈希吗值
str.hashCode();

获得指定字符串第一次出现的索引位置(返回值是int类型)
找不到指定的字符串内容返回值是-1
str.indexOf("a");
str.indexOf("a",1) // 从第二个元素开始查找

获得指定字符串最后一次出现的索引位置(返回值是int类型)
找不到指定的字符串内容返回值是-1
str.lastIndexOf("a");
str.lastIndexOf("a",1); // 从第一个开始查到最后一次出现的位置

获得当前字符串的副本(返回值是String类型)
str.intern(); //返回是一个常量池的数据(地址)

判断字符串是否是空(返回值是boolean类型)
str.isEmpty();

使用分隔符连接字符串内容(返回值是String类型)
String.join("_","a","b","c"); // a_b_c  后面可以写多个数据

判断字符串是否匹配正则的要求(返回值是boolean类型)
str.matches("abc"); // abc就是正则

使用指定字符串替换字符串内容(返回值是String类型)
str.replace('a','b'); // 将所有a替换成b
str.replace("a","abc"); // 将所有a替换成abc
str.replaceAll("支持正则", "abc"); // 可以支持正则表达式
str.replaceFirst("a","abc");  // 只替换第一个出现的a，支持正则

将字符串使用指定的正则表达式进行分割(返回值是String[]类型)
str.split("a"); // 通过a把字符串分隔开 支持正则
str.split("a",2) // 将字符串分为2个，通过a分割

截取部分字符串内容(返回值是String类型)
str.substring("a");  //从a出现的位置开始截取
str.substring(1,3);  // 从第一个索引开始截取到第三个索引，包头不包尾

转换为大小写(返回值是String类型)
str.toUpperCase(); //转换为大写
str.toLowerCase(); //转换为小写

去掉字符串左右两边空格(返回值是String类型)
str.trim();

去掉中间空格
str.trim.replace(" ","");
str.trim.replaceAll(" ","");
```





