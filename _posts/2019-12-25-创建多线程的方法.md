---
layout:     post
title:      创建多线程的方法
subtitle:   java多线程
date:       2019-12-25
author:     极客小祥
header-img: img/text/JAVA.jpg
catalog: true
tags: 
    - JAVA
---

# 1、继承Thread类

```java
public class MyThread extends Thread {
    // 重新run方法就是创建了多线程
    @Override
    public void run() {
        // 放需要执行的代码
    }
    
    // 使用
    public static void main(String[] args) {
        MyThread et1 = new MyThread();
        // 使用start方法执行
        et1.start();
    }
}
```

# 2、实现Runnable接口

```java
public class MyRunnable implements Runnable{
    // 实现run方法
    @Override
    public void run() {
        // 放需要执行的代码
    }
    // 使用
    public static void main(String[] args) {
        // 用Runnable的接口实现类的实例作为Thread的target
        Thread t1 = new Thread(new MyRunnable());
        // 调用
        t1.start();
    }
}
```

# 3、匿名内部类

```java
public class App {
    public static void main(String[] args){
        // 第一个方法，使用Runnable的方式
        new Thread(new Runnable() {
            @Override
            public void run() {
                // 需要执行的代码
            }
        }).start();

        // 第二个方法
        new Thread(){
            @Override
            public void run(){
                // 需要执行的代码
            }
        }.start();
    }
}
```

# 4、java.util.concurrent.Callable工具类

```java
public class CallableTest {
    public static void main(String[] args) throws Exception {
        Callable<Integer> call = new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                // 需要执行的代码
                // 返回值为Integer
                return 1;
            }
        };
        // Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果
        // FutureTask类实现了RunnableFuture接口,RunnableFuture继承了Runnable接口和Future接口
        FutureTask<Integer> task = new FutureTask<>(call);
        Thread t =  new Thread(task);
        t.start();
    }
}
```

# 5、java.util.Timer工具类

```java
public class TimerTest {
    public static void main(String[] args) throws Exception {
         // 启动定时器线程，并在10000毫秒后执行TimerTask实例的run方法，每隔3000毫秒执行一次
        new Timer().schedule(new TimerTask() {
            @Override
            public void run() {
                // 需要执行的代码
            }
        }, 10000,3000);
    }
}
```

# 6、java.util.concurrent.Executors工具类

```java
public class ThreadPoolTest {
    public static void main(String[] args) {
        // 创建线程池,10个
        // 通过java.util.concurrent.ExecutorService接口对象来执行任务
        // 该接口对象通过工具类java.util.concurrent.Executors的静态方法来创建
        ExecutorService threadPool = Executors.newFixedThreadPool(10);
        while(true) {
            threadPool.execute(new Runnable() { // 提交多个线程任务，并执行
                @Override
                public void run() {
                    // 需要执行的代码
                }
            });
        }
    }
}
```